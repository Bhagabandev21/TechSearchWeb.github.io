	<!doctype html>
	<html lang="en">
	<head>
	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/5.0.0-alpha1/css/bootstrap.min.css" integrity="sha384-r4NyP46KrjDleawBgD5tp8Y7UzmLA05oM1iAEQ17CSuDqnUK2+k9luXQOfXJCJ4I" crossorigin="anonymous">

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<!-- JavaScript and dependencies -->

	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous">

	</script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/5.0.0-alpha1/js/bootstrap.min.js" integrity="sha384-oesi62hOLfzrys4LxRF63OJCXdXDipiYWBnvTl9Y9/TRlw5xlKIEHpNyvvDShgf/" crossorigin="anonymous">
	</script>

	<!-- Bootstrap CSS -->

	<!-- CSS only -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/5.0.0-alpha1/css/bootstrap.min.css" integrity="sha384-r4NyP46KrjDleawBgD5tp8Y7UzmLA05oM1iAEQ17CSuDqnUK2+k9luXQOfXJCJ4I" crossorigin="anonymous">

	<title>TechSearhWeb</title>
	<link rel="icon" type="image/png" href="images\TBWeb.png"/>
	</head>
	<body>
	<nav class="navbar navbar-expand-md sticky-buttom"


	<div>
	<!-- <div class="col-sm-8 col-md-8 col-lg-8 border border-summary px-md-1 bg-white"> -->
	  <a href="index.html"><img class="logo" src="images\TBWeb.png" width="290"><br></a>
	  <img class="" src="" width="">



	  <a href="corejava.html"><img class="image" src="images\java.png" width="40" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="Java">
 </a>
	  <img class="image" src="images\blankimage.png" width="60">

	  <!-- <img class="image" src="images\spring.png" width="50"> -->
	  <a href="springboot.html"><img class="image" src="images\springboot.jpg" width="30" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="springBoot"></a>
	  <img class="image" src="images\blankimage.png" width="60">

	  <a href="webservice.html"><img class="image" src="images\webservice.jpg" width="30"
	  class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="Webservice"></a>
	  <img class="image" src="images\blankimage.png" width="60" >

	  <a href="cucumber.html"><img class="image" src="images\cucumber.png" width="30" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="Cucumber"></a>

	  <img class="image" src="images\blankimage.png" width="60">



	  <a href="selenium.html"><img class="image" src="images\Selenium.jpg" width="40" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="Selenium"></a>

	  <img class="image" src="images\blankimage.png" width="60">
	  <!-- <img class="text" src="images\Selenium.jpg" width="50">    ff -->


	  <a href="nodejs.html"><img class="image" src="images\nodejs1.png" width="70" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="NodeJs"></a>
	  <img class="image" src="images\blankimage.png" width="60">
	  <a href="interviewQ&A.html"><img class="image" src="images\intQues.png" width="40" class="btn btn-secondary" data-toggle="tooltip" data-placement="bottom" title="InterviewQuestions&Answers"></a>


	</div>
	</div>
	</nav>



	<nav class="navbar navbar-expand-lg navbar-dark bg-primary sticky-top">
	<!-- <nav class="navbar navbar-expand-lg" style="background-color: lightgreen;"> -->
  <a class="navbar-brand"  fixed-top href="#"></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapse" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
		<span class="navbar-toggler-icon"></span>
		<span class="icon-bar"></span>
        <span class="icon-bar"></span>

  </button>


  <div class="collapse navbar-collapse" id="collapse">



    <ul class="navbar-nav navbar-sticky-top">

      <li class="nav-item active">
        <a class="nav-link" href="home.html">Home <span class="sr-only">(current)</span></a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="corejava.html">Core Java</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="oops.html">Oops</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="string.html">String</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="exception.html">Exception</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="collection.html">Collections</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="thread.html">Thread</a>
      </li>


	  <li class="nav-item">
        <a class="nav-link" href="spring.html">Spring</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="springboot.html">Spring Boot</a>
      </li>

	  <li class="nav-item">
        <a class="nav-link" href="webservice.html">Web Services</a>
      </li>


	  <li class="nav-item">
        <a class="nav-link" href="nodejs.html">Node Js</a>

		<li class="nav-item">
        <a class="nav-link" href="selenium.html">Selenium</a>
		</li>

		<li class="nav-item">
        <a class="nav-link" href="interviewQ&A.html">Interview Q&A</a>
		</li>

      </li>



    </ul>
  </div>
</nav>


<body>
<!-- Container Start -->
<div class="container-fluid">

  <div class="row">

 <!-- Division Start -->
  <!-- First Division -->


	<div id="box" class="col-sm-2 col-md-2 col-lg-2 border-0 border shadow-lg bg-white">
	<p class="user-select-auto">

	<a href="collectionsort.html">how to sort the Collection objects in Java?</a><br>
	<a href="collectionDupRemove.html"> What are the ways to remove duplicates from ArrayList?</a><br>
	<a href="collectionHashmap.html">What is WeakHashMap</a><br>
	<a href="collectionthreadsafe.html">What are the methods to make collection thread-safe?</a><br>
	<a href="collectionpeek.html">What is the peek()of the Queue interface?</a><br>
	<a href="collectionjoin.html">How to join multiple ArrayLists?</a><br>
	<a href="collectionmapentry.html">What is map. entry In Map?</a><br> 
	<a href="collectionproperties.html">What is the Properties file in collection?</a><br>
	


	</p>
	</div>


	<!-- Second Doivision -->
    <!-- <div class="col bg-warning col-lg-8 text-left"> -->
	<div id="box" class="col-sm-8 col-md-8 col-lg-8 border-0 border shadow bg-white">
	<p class="user-select-auto">
	<p class="font-weight-normal">
<b>Collections in Java</b><br>
The Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.<br>

Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.<br>

Java Collection means a single unit of objects. Java Collection framework provides many interfaces (Set, List, Queue, Deque) and classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet).<br>

The Java Collections Framework is a collection of interfaces and classes which helps in storing and processing the data efficiently. This framework has several useful classes which have tons of useful functions which makes a programmer task super easy. <br>

<b>There are different type collections</b><br>
1. ArrayList<br>
2. LinkedList<br>
3. Vector<br>
4. HashSet<br>
5. LinkedHashSet<br>
6. TreeSet<br>
7. HashMap<br>
8. TreeMap<br>
9. LinkedHashMap<br>
10. Hashtable<br>
11. Iterator and ListIterator<br>
12. Comparable and Comparator<br>

<!-- <img src="E:\WebSites\BootStrapJavaProject\java-collection-hierarchy.png",height="10",width="20"> -->
<br>

<b>Collections List</b><br>
A List is an ordered Collection (sometimes called a sequence). Lists may contain duplicate elements. Elements can be inserted or accessed by their position in the list, using a zero-based index.<br>
ArrayList
Here is the list of all the tutorials published on the ArrayList.

<b>Methods of Collection interface</b><br>
There are many methods declared in the Collection interface. They are as follows:
<table border="1" cellpadding="10" cellspacing="20" align="center" width="100%">
<th bgcolor="lightgray" align="center">No</th>
<th bgcolor="lightgray" align="center">Method</th>
<th bgcolor="lightgray" align="center">Description</th>
<tr bgcolor="white">
	<td>1</td>
    <td>public boolean add(E e)</td>
	<td>It is used to insert an element in this collection.</td>
<tr bgcolor="lightgray">
	<td>2</td>
    <td>public boolean addAll(Collection<? extends E> c)</td>
	<td>It is used to insert the specified collection elements in the invoking collection.
	</td>
</tr>

<tr bgcolor="white">
	<td>3</td>
    <td>public boolean remove(Object element)</td>
	<td>It is used to delete an element from the collection.</td>
</tr>
<tr bgcolor="lightgray">
	<td>4</td>
    <td>public boolean removeAll(Collection<?> c)</td>
	<td>It is used to delete all the elements of the specified collection from the invoking collection.</td>
</tr>

<tr bgcolor="white">
	<td>5</td>
    <td>default boolean removeIf(Predicate<? super E> filter)</td>
	<td>It is used to delete all the elements of the collection that satisfy the specified predicate.</td>
<tr bgcolor="lightgray">
	<td>6</td>
    <td>public boolean retainAll(Collection<?> c)</td>
	<td>It is used to delete all the elements of invoking collection except the specified collection.</td>
</tr>
<tr bgcolor="white">
	<td>7</td>
    <td>public int size()</td>
	<td>It returns the total number of elements in the collection.</td>
<tr bgcolor="lightgray">
	<td>8</td>
	<td>public void clear()</td>
    <td>It removes the total number of elements from the collection.</td>
</tr>

<tr bgcolor="white">
	<td>9</td>
    <td>public boolean contains(Object element)</td>
	<td>It is used to search an element.</td>
<tr bgcolor="lightgray">
	<td>10</td>
	<td>public boolean containsAll(Collection<?> c)</td>
    <td>It is used to search the specified collection in the collection.</td>
</tr>
<tr bgcolor="white">
	<td>11</td>
    <td>public Iterator iterator()</td>
	<td>It returns an iterator.</td>
</tr>
<tr bgcolor="lightgray">
	<td>12</td>
	<td>public Object[] toArray()</td>
    <td>It converts collection into array.</td>
</tr>
<tr bgcolor="white">
	<td>13</td>
    <td>public <T> T[] toArray(T[] a)</td>
	<td>It converts collection into array. Here, the runtime type of the returned array is that of the specified array.</td>
<tr bgcolor="lightgray">
	<td>14</td>
	<td>public boolean isEmpty()</td>
    <td>It checks if collection is empty.</td>
</tr>
<tr bgcolor="white">
	<td>15</td>
    <td>default Stream<E> parallelStream()</td>
	<td>It returns a possibly parallel Stream with the collection as its source.</td>
<tr bgcolor="lightgray">
	<td>16</td>
	<td>default Stream<E> stream()</td>
    <td>It returns a sequential Stream with the collection as its source.</td>
<tr bgcolor="white">
	<td>17</td>
    <td>default Spliterator<E> spliterator()</td>
	<td>It generates a Spliterator over the specified elements in the collection.</td>
<tr bgcolor="lightgray">
	<td>18</td>
	<td>public boolean equals(Object element)</td>
    <td>It matches two collections.</td>
	<tr bgcolor="white">
	<td>19</td>
    <td>public int hashCode()</td>
	<td>It returns the hash code number of the collection.</td>

</tr>

</table>

<b>Iterator interface</b><br>
Iterator interface provides the facility of iterating the elements in a forward direction only.<br>

<b>Methods of Iterator interface</b><br>
There are only three methods in the Iterator interface. They are:<br>

<table border="1" cellpadding="10" cellspacing="20" align="center" width="100%">
<th bgcolor="lightgray" align="center">No.</th>
<th bgcolor="lightgray" align="center">Method</th>
<th bgcolor="lightgray" align="center">Description</th>
<tr bgcolor="white">
	<td>1</td>
    <td>public boolean hasNext()</td>
	<td>It returns true if the iterator has more elements otherwise it returns false.</td>
<tr bgcolor="lightgray">
	<td>2</td>
    <td>public Object next()</td>
	<td>It returns the element and moves the cursor pointer to the next element.</td>
</tr>

<tr bgcolor="white">
	<td>3</td>
    <td>public void remove()</td>
	<td>It removes the last elements returned by the iterator. It is less used.</td>
</table>

<b>Iterable Interface</b><br>
The Iterable interface is the root interface for all the collection classes. The Collection interface extends the Iterable interface and therefore all the subclasses of Collection interface also implement the Iterable interface.<br>

It contains only one abstract method. i.e.,

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>Iterator<T> iterator() </td>
	</tr>


</table>
It returns the iterator over the elements of type T.
<br>

<b>Collection Interface</b><br>
The Collection interface is the interface which is implemented by all the classes in the collection framework. It declares the methods that every collection will have. In other words, we can say that the Collection interface builds the foundation on which the collection framework depends.<br>

Some of the methods of Collection interface are Boolean add ( Object obj), Boolean addAll ( Collection c), void clear(), etc. which are implemented by all the subclasses of Collection interface.<br>

<b>List Interface</b><br>
List interface is the child interface of Collection interface. It inhibits a list type data structure in which we can store the ordered collection of objects. It can have duplicate values.<br>

List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.
<br>

To instantiate the List interface, we must use :

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>List <data-type> list1= new ArrayList();  </td>	
	</tr>
	<tr>
		<td>List <data-type> list2 = new LinkedList();  </td>		
	</tr>
	<tr>
		<td>List <data-type> list3 = new Vector();  </td>
	</tr>
	<tr>
		<td>List <data-type> list4 = new Stack();  </td>
	</tr>
	
</table>
<br>
There are various methods in List interface that can be used to insert, delete, and access the elements from the list.<br>

The classes that implement the List interface are given below.
<br>
<b>ArrayList</b><br>
The ArrayList class implements the List interface. It uses a dynamic array to store the duplicate element of different data types. The ArrayList class maintains the insertion order and is non-synchronized. The elements stored in the ArrayList class can be randomly accessed. Consider the following example.<br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>class ArrayListTest{</td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){  </td>
	</tr>
	<tr>
		<td>ArrayList<String> list=new ArrayList<String>();//Creating arraylist  </td>
	</tr>
	<tr>
		<td>list.add("Rahul");//Adding object in arraylist  </td>
	</tr>
	<tr>
		<td>list.add("Ajay");  </td>
	</tr>
	<tr>
		<td>list.add("Gaurav");  </td>
	</tr>
	<tr>
		<td>list.add("Virat");</td>
	</tr>
	<tr>
		<td>//Traversing list through Iterator  </td>
	</tr>
	<tr>
		<td>Iterator itr=list.iterator();  </td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Rahul</td>
	</tr>
	<tr>
		<td>Ajay</td>
	</tr>
	<tr>
		<td>Gaurav</td>
	</tr>
	<tr>
		<td>Virat</td>
	</tr>
	
	
</table>

<b>LinkedList</b><br>
LinkedList implements the Collection interface. It uses a doubly linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.<br>

Consider the following example.<br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;  </td>	
	</tr>
	<tr>
		<td>public class LinkedListTest{  </td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){  </td>
	</tr>
	<tr>
		<td>LinkedList<String> al=new LinkedList<String>(); </td>
	</tr>
	<tr>
		<td>al.add("Rohan");  </td>
	</tr>
	<tr>
		<td>al.add("Prem");  </td>
	</tr>
	<tr>
		<td>al.add("Sagar");  </td>
	</tr>
	<tr>
		<td>al.add("Rohan");  </td>
	</tr>
	<tr>
		<td>Iterator<String> itr=al.iterator();  </td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Rohan</td>
	</tr>
	<tr>
		<td>Prem</td>
	</tr>
	<tr>
		<td>Akash</td>
	</tr>
	<tr>
		<td>Rohan</td>
	</tr>
	
</table>

<b>Vector</b><br>

A vector provides us with dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed. This is identical to ArrayList in terms of implementation. However, the primary difference between a vector and an ArrayList is that a Vector is synchronized and an ArrayList is non-synchronized. Let’s understand the Vector with an example:


<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*; </td>	
	</tr>
	<tr>
		<td>public class VectorTest{  </td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){ </td>
	</tr>
	<tr>
		<td>Vector<String> v=new Vector<String>();  </td>
	</tr>
	<tr>
		<td>v.add("Karan");  </td>
	</tr>
	<tr>
		<td>v.add("Suraj");  </td>i
	</tr>
	<tr>
		<td>v.add("Rohit");</td>h
	</tr>
	<tr>
		<td>v.add("Prem");  </td>
	</tr>
	<tr>
		<td>Iterator<String> itr=v.iterator();</td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){</td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	</tr>
	<tr>
		<td>Karan</td>
	</tr>
	<tr>
		<td>Suraj</td>
	</tr>
	<tr>
		<td>Rohit</td>
	</tr>
	<tr>
		<td>Prem</td>
	</tr>
	
</table>

<b>Stack</b><br>
Stack class models and implements the Stack data structure. The class is based on the basic principle of last-in-first-out. In addition to the basic push and pop operations, the class provides three more functions of empty, search and peek. The class can also be referred to as the subclass of Vector. Let’s understand the stack with an example:

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class StackTest</td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){</td>
	</tr>
	<tr>
		<td>Stack<String> stack = new Stack<String>();</td>
	</tr>
	<tr>
		<td>stack.push("Karan");</td>
	</tr>
	<tr>
		<td>stack.push("Suraj");</td>
	</tr>
	<tr>
		<td>stack.push("Rohit");</td
	</tr>
	<tr>
		<td>stack.push("Prem");</td>
	</tr>
	<tr>
		<td>stack.push("Rohan");</td>
	</tr>
	<tr>
		<td>stack.pop(); </td>
	</tr>
	<tr>
	<tr>
		<td>Iterator<String> itr=stack.iterator();  </td>
	</tr>
		<td>while(itr.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	
	<tr>
		<td>Karan</td>
	</tr>
	<tr>
		<td>Suraj</td>
	</tr>
	<tr>
		<td>Rohit</td>
	</tr>
		
</table>


<b>Queue Interface</b><br>
a queue interface maintains the FIFO(First In First Out) order similar to a real-world queue line. This interface is dedicated to storing all the elements where the order of the elements matter. For example, whenever we try to book a ticket, the tickets are sold at the first come first serve basis. Therefore, the person whose request arrives first into the queue gets the ticket. There are various classes like PriorityQueue, Deque, ArrayDeque, etc. Since all these subclasses implement the queue, we can instantiate a queue object with any of these classes. 
<br>
Queue interface can be instantiated as:
 
<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>Queue<String> q1 = new PriorityQueue(); </td>	
	</tr>
	<tr>
		<td>Queue<String> q2 = new ArrayDeque();</td>		
	</tr>
	
</table>
<br>
There are various classes that implement the Queue interface, some of them are given below.

<b>PriorityQueue</b><br>
The PriorityQueue class implements the Queue interface. It holds the elements or objects which are to be processed by their priorities. PriorityQueue doesn't allow null values to be stored in the queue.<br>

For example.


<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class PriorityQueueTest{  </td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){  </td>
	</tr>
	<tr>
		<td>PriorityQueue<String> queue=new PriorityQueue<String>();  </td>
	</tr>
	<tr>
		<td>queue.add("Rohit");  </td>
	</tr>
	<tr>
		<td>queue.add("Raj");  </td>
	</tr>
	<tr>
		<td>queue.add("Prem");</td>
	</tr>
	<tr>
		<td>queue.add("Suraj");  </td>
	</tr>
	<tr>
		<td>System.out.println("head:"+queue.element()); </td>
	</tr>
	<tr>
		<td>System.out.println("head:"+queue.peek()); </td>
	</tr>
	<tr>
		<td>System.out.println("iterating the queue elements:");  </td>
	</tr>
	<tr>
		<td>Iterator itr=queue.iterator(); </td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>queue.remove();  </td>
	</tr>
	<tr>
		<td>queue.poll();</td>
	</tr>
	<tr>
		<td>System.out.println("after removing two elements:");</td>
	</tr>
	<tr>
		<td>Iterator<String> itr2=queue.iterator();</td>
	</tr>
	<tr>
		<td>while(itr2.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr2.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>head:Rohit</td>
	</tr>
	<tr>
		<td>head:Rohit</td>
	</tr>
	<tr>
		<td>iterating the queue elements:</td>
	</tr>
	<tr>
		<td>Rohit</td>
	</tr>
	<tr>
		<td>Suraj</td>
	</tr>
	<tr>
		<td>Prem</td>
	</tr>
	<tr>
		<td>Raj</td>
	</tr>
	<tr>
		<td>after removing two elements:</td>
	</tr>
	<tr>
		<td>Suraj</td>
	</tr>
	<tr>
		<td>Raj</td>
	</tr>
	<tr>
		<td></td>
	</tr>
	
</table>
<b>Deque Interface</b><br>
This is a very slight variation of the queue data structure. Deque, also known as a double-ended queue, is a data structure where we can add and remove the elements from both the ends of the queue. This interface extends the queue interface. The class which implements this interface is ArrayDeque. Since this class implements the deque, we can instantiate a deque object with this class. For example
<br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>Deque d = new ArrayDeque();</td>
	</tr>
	
</table>

<b>ArrayDeque</b><br>
ArrayDeque class implements the Deque interface. It facilitates us to use the Deque. Unlike queue, we can add or delete the elements from both the ends.

ArrayDeque is faster than ArrayList and Stack and has no capacity restrictions.

Consider the following example.
<br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*; </td>	
	</tr>
	<tr>
		<td>public class ArrayDequeTest{  </td>		
	</tr>
	<tr>
		<td>public static void main(String[] args) {  </td>
	</tr>
	<tr>
		<td>Deque<String> deque = new ArrayDeque<String>();  </td>
	</tr>
	<tr>
		<td>deque.add("Rahul");  </td>
	</tr>
	<tr>
		<td>deque.add("Karan");</td>
	</tr>
	<tr>
		<td>deque.add("Ajay");</td>
	</tr>
	<tr>
		<td>//Traversing elements</td>
	</tr>
	<tr>
		<td>for (String str : deque) {</td>
	</tr>
	<tr>
		<td>System.out.println(str);</td>
	</tr>
	
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Rahul</td>
	</tr>
	<tr>
		<td>Karan</td>
	</tr>
	<tr>
		<td>Ajay</td>
	</tr>
					
</table>

<b>Set Interface</b><br>
Set Interface in Java is present in java.util package. It extends the Collection interface. It represents the unordered set of elements which doesn't allow us to store the duplicate items. We can store at most one null value in Set. Set is implemented by HashSet, LinkedHashSet, and TreeSet.

Set can be instantiated as:

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>Set<data-type> s1 = new HashSet<data-type>(); </td>	
	</tr>
	<tr>
		<td>Set<data-type> s2 = new LinkedHashSet<data-type>(); </td>		
	</tr>
	<tr>
		<td>Set<data-type> s3 = new TreeSet<data-type>();  </td>
	</tr>
	
</table>

<b>HashSet</b><br>
HashSet class implements Set Interface. It represents the collection that uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains unique items.
<br>
Consider the following example.

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;  </td>	
	</tr>
	<tr>
		<td>public class HashSetTest{ </td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){  </td>
	</tr>
	<tr>
		<td>//Creating HashSet and adding elements  </td>
	</tr>
	<tr>
		<td>HashSet<String> set=new HashSet<String>();  </td>
	</tr>
	<tr>
		<td>set.add("Prem");</td>
	</tr>
	<tr>
		<td>set.add("Raj");  </td>
	</tr>
	<tr>
		<td>set.add("Prem");  </td>
	</tr>
	<tr>
		<td>set.add("Rohit");  </td>
	</tr>
	<tr>
		<td>//Traversing elements  </td>
	</tr>
	<tr>
		<td>Iterator<String> itr=set.iterator();  </td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){  </td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	
	<tr>
		<td>}</td>
	</tr>
	
	<tr>
		<td>Output:</td>
	</tr>
	
	<tr>
		<td>Prem</td>
	</tr>
		<tr>
		<td>Raj</td>
	</tr>
	<tr>
		<td>Rohit</td>
	</tr>
	
</table>

<b>LinkedHashSet</b><br>
LinkedHashSet class represents the LinkedList implementation of Set Interface. It extends the HashSet class and implements Set interface. Like HashSet, It also contains unique elements. It maintains the insertion order and permits null elements.
<br>
example.

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;  </td>	
	</tr>
	<tr>
		<td>public class LinkedHashSetTest{  </td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){  </td>
	</tr>
	<tr>
		<td>LinkedHashSet<String> set=new LinkedHashSet<String>();</td>
	</tr>
	<tr>
		<td>set.add("Rohan");</td>
	</tr>
	<tr>
		<td>set.add("Raj");</td>
	</tr>
	<tr>
		<td>set.add("Gaurav");</td>
	</tr>
	<tr>
		<td>set.add("Prem");</td>
	</tr>
	<tr>
		<td>set.add("Raj");</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Rohan</td>
	</tr>
	<tr>
		<td>Raj</td>
	</tr>
	<tr>
		<td>Gaurav</td>
	</tr>
	<tr>
		<td>Prem</td>
	</tr>
	
</table>


<b>SortedSet Interface</b><br>
SortedSet is the alternate of Set interface that provides a total ordering on its elements. The elements of the SortedSet are arranged in the increasing (ascending) order. The SortedSet provides the additional methods that inhibit the natural ordering of the elements.
<br>

The SortedSet can be instantiated as:
<br>


<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>SortedSet<data-type> set = new TreeSet(); </td>	
	</tr>
	
</table> 

<b>TreeSet</b><br>
Java TreeSet class implements the Set interface that uses a tree for storage. Like HashSet, TreeSet also contains unique elements. However, the access and retrieval time of TreeSet is quite fast. The elements in TreeSet stored in ascending order.r
<br>

Consider the following example:
<br>
<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class TreeSetTest{</td>		
	</tr>
	<tr>
		<td>//Creating and adding elements</td>
	</tr>
	<tr>
		<td>TreeSet<String> set=new TreeSet<String>();</td>
	</tr>
	<tr>
		<td>set.add("Rohit");</td>
	</tr>
	<tr>
		<td>set.add("Prem");</td>
	</tr>
	<tr>
		<td>set.add("Raj");</td>
	</tr>
	<tr>
		<td>set.add("Rohit");</td>
	</tr>
	<tr>
		<td>//traversing elements</td>
	</tr>
	<tr>
		<td>Iterator<String> itr=set.iterator();</td>
	</tr>
	<tr>
		<td>while(itr.hasNext()){</td>
	</tr>
	<tr>
		<td>System.out.println(itr.next());</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Prem</td>
	</tr>
	<tr>
		<td>Raj</td>
	</tr>
	<tr>
		<td>Rohit</td>
	</tr>
</table>

<b>ArrayList</b><br>
Java ArrayList class uses a dynamic array for storing the elements. It is like an array,but there is no size limit. We can add or remove elements anytime. So, it is much more flexible than the traditional array. It is found in the java.util package. It is like the Vector in C++.
<br>

The ArrayList in Java can have the duplicate elements also. It implements the List interface so we can use all the methods of List interface here. The ArrayList maintains the insertion order internally.
<br>

It inherits the AbstractList class and implements List interface.
<br>

The important points about Java ArrayList class are:<br>

Java ArrayList class can contain duplicate elements.<br>
Java ArrayList class maintains insertion order.<br>
Java ArrayList class is non synchronized.<br>
Java ArrayList allows random access because array works at the index basis.<br>
In ArrayList, manipulation is little bit slower than the LinkedList in Java because a lot of shifting needs to occur if any element is removed from the array list.
<br>


<b>Hierarchy of ArrayList class</b><br>
As shown in the above diagram, Java ArrayList class extends AbstractList class which implements List interface. The List interface extends the Collection and Iterable interfaces in hierarchical order.<br>

ArrayList class declaration<br>
Let's see the declaration for java.util.ArrayList class.

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable  </td>	
	</tr>
	
</table>


<b>Constructors of ArrayList</b><br>

<table border="1" cellpadding="10" cellspacing="20" align="center" width="100%">
<th bgcolor="lightgray" align="center">Constructor</th>
<th bgcolor="lightgray" align="center">Description</th>
<tr bgcolor="white">
	<td>ArrayList()</td>
    <td>It is used to build an empty array list.</td>
<tr bgcolor="lightgray">
	<td>ArrayList(Collection<? extends E> c)</td>
    <td>It is used to build an array list that is initialized with the elements of the collection c.</td>
</tr>

<tr bgcolor="white">
	<td>ArrayList(int capacity)</td>
    <td>It is used to build an array list that has the specified initial capacity.</td>

</table>

<b>Methods of ArrayList</b><br>

<table border="1" cellpadding="10" cellspacing="20" align="center" width="100%">
<th bgcolor="lightgray" align="center">Method</th>
<th bgcolor="lightgray" align="center">Description</th>
<tr bgcolor="white">
	<td>void add(int index, E element)</td>
    <td>It is used to insert the specified element at the specified position in a list.</td>
<tr bgcolor="lightgray">
	<td>boolean add(E e)</td>
    <td>It is used to append the specified element at the end of a list.</td>
</tr>

<tr bgcolor="white">
	<td>boolean addAll(Collection<? extends E> c)</td>
    <td>It is used to append all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.</td>
<tr bgcolor="lightgray">
	<td>boolean addAll(int index, Collection<? extends E> c)</td>
    <td>It is used to append all the elements in the specified collection, starting at the specified position of the list.</td>
</tr>
<tr bgcolor="white">
	<td>void clear()</td>
    <td>It is used to remove all of the elements from this list.</td>
<tr bgcolor="lightgray">
	<td>void ensureCapacity(int requiredCapacity)</td>
    <td>It is used to enhance the capacity of an ArrayList instance.</td>
</tr>
<tr bgcolor="white">
	<td>E get(int index)</td>
    <td>It is used to fetch the element from the particular position of the list.</td>
<tr bgcolor="lightgray">
	<td>boolean isEmpty()</td>
    <td>It returns true if the list is empty, otherwise false.</td>
</tr>
<tr bgcolor="white">
	<td>int lastIndexOf(Object o)</td>
    <td>It is used to return the index in this list of the last occurrence of the specified element, or -1 if the list does not contain this element.</td>
<tr bgcolor="lightgray">
	<td>Object[] toArray()</td>
    <td>It is used to return an array containing all of the elements in this list in the correct order.</td>
</tr>
<tr bgcolor="white">
	<td><T> T[] toArray(T[] a)</td>
    <td>It is used to return an array containing all of the elements in this list in the correct order.</td>
<tr bgcolor="lightgray">
	<td>Object clone()</td>
    <td>It is used to return a shallow copy of an ArrayList.</td>
</tr>
<tr bgcolor="white">
	<td>boolean contains(Object o)</td>
    <td>It returns true if the list contains the specified element</td>
<tr bgcolor="lightgray">
	<td>int indexOf(Object o)</td>
    <td>It is used to return the index in this list of the first occurrence of the specified element, or -1 if the List does not contain this element.</td>
</tr>
<tr bgcolor="white">
	<td>E remove(int index)</td>
    <td>It is used to remove the element present at the specified position in the list.</td>
<tr bgcolor="lightgray">
	<td>boolean remove(Object o)</td>
    <td>It is used to remove the first occurrence of the specified element.</td>
</tr>
<tr bgcolor="white">
	<td>boolean removeAll(Collection<?> c)</td>
    <td>It is used to remove all the elements from the list.</td>
<tr bgcolor="lightgray">
	<td>boolean removeIf(Predicate<? super E> filter)</td>
    <td>It is used to remove all the elements from the list that satisfies the given predicate.</td>
</tr>
<tr bgcolor="white">
	<td>protected void removeRange(int fromIndex, int toIndex)</td>
    <td>It is used to remove all the elements lies within the given range.</td>
<tr bgcolor="lightgray">
	<td>void replaceAll(UnaryOperator<E> operator)</td>
    <td>It is used to replace all the elements from the list with the specified element.</td>
</tr>
<tr bgcolor="white">
	<td>void retainAll(Collection<?> c)</td>
    <td>It is used to retain all the elements in the list that are present in the specified collection.</td>
<tr bgcolor="lightgray">
	<td>E set(int index, E element)</td>
    <td>It is used to replace the specified element in the list, present at the specified position.</td>
</tr>
<tr bgcolor="white">
	<td>void sort(Comparator<? super E> c)</td>
    <td>It is used to sort the elements of the list on the basis of specified comparator.</td>
<tr bgcolor="lightgray">
	<td>Spliterator<E> spliterator()</td>
    <td>It is used to create spliterator over the elements in a list.</td>
</tr>
<tr bgcolor="white">
	<td>List<E> subList(int fromIndex, int toIndex)</td>
    <td>It is used to fetch all the elements lies within the given range.</td>
<tr bgcolor="lightgray">
	<td></td>
    <td></td>
</tr>
<tr bgcolor="white">
	<td>int size()</td>
    <td>It is used to return the number of elements present in the list.</td>
<tr bgcolor="lightgray">
	<td>void trimToSize()</td>
    <td>It is used to trim the capacity of this ArrayList instance to be the list's current size.</td>
</tr>

<tr bgcolor="white">
	<td>Iterator()</td>
    <td></td>
<tr bgcolor="lightgray">
	<td>listIterator()</td>
    <td></td>
</tr>



</table>

<b>ArrayList Example</b><br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class ArrayListTest{{</td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){</td>
	</tr>
	<tr>
		<td>ArrayList<String> list=new ArrayList<String>();//Creating arraylist </td>
	</tr>
	<tr>
		<td>list.add("Apple");//Adding object in arraylist </td>
	</tr>
	<tr>
		<td>list.add("Sony");</td>
	</tr>
	<tr>
		<td>list.add("Samsung"); </td>
	</tr>
	<tr>
		<td>list.add("Nokia");</td>
	</tr>
	<tr>
		<td>//Printing the arraylist object</td>
	</tr>
	<tr>
		<td>System.out.println(list);  </td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>[Apple,Sony,Samsung,Nokia]</td>
	</tr>
	<tr>
		<td></td>
	</tr>
	<tr>
		<td></td>
	</tr>
	<tr>
		<td></td>
	</tr>
	
</table>


<b>Iterating ArrayList using Iterator</b><br>

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class ArrayListTest{{</td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){</td>
	</tr>
	<tr>
		<td>ArrayList<String> list=new ArrayList<String>();//Creating arraylist </td>
	</tr>
	<tr>
		<td>list.add("Apple");//Adding object in arraylist </td>
	</tr>
	<tr>
		<td>list.add("Sony");</td>
	</tr>
	<tr>
		<td>list.add("Samsung"); </td>
	</tr>
	<tr>
		<td>list.add("Nokia");</td>
	</tr>
	<tr>
		<td>//Traversing list through Iterator</td>
	</tr>
	<tr>
		<td>Iterator itr=list.iterator();//getting the Iterator</td>
	</tr>
	<tr>
		<td>while(itr.hasNext());{//check if iterator has the elements  </td>
	</tr>
	
	<tr>
		<td>System.out.println(itr.next());//printing the element and move to next</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Apple</td>
	</tr>
	<tr>
		<td>Sony</td>
	</tr>
	<tr>
		<td>Samsung</td>
	</tr>
	<tr>
		<td>Nokia</td>
	</tr>
	
</table>

<b>Sorting ArrayList</b><br>
The java.util package provides a utility class Collections which has the static method sort(). Using the Collections.sort() method, we can easily sort the ArrayList.

<table border="1" bgcolor="lightgray" align="center" width="100%">
	<tr>
		<td>import java.util.*;</td>	
	</tr>
	<tr>
		<td>public class ArrayListTest{{</td>		
	</tr>
	<tr>
		<td>public static void main(String args[]){</td>
	</tr>
	<tr>
		<td>ArrayList<String> list1=new ArrayList<String>();//Creating list of mobile brand </td>
	</tr>
	<tr>
		<td>list1.add("Apple");//Adding object in arraylist </td>
	</tr>
	<tr>
		<td>list1.add("Sony");</td>
	</tr>
	<tr>
		<td>list1.add("Samsung"); </td>
	</tr>
	<tr>
		<td>list1.add("Nokia");</td>
	</tr>
	<tr>
		<td>//sorting the list</td>
	</tr>
	<tr>
		<td>collection.sort(list1);</td>
	</tr>
	<tr>
		<td>//Traversing list through the for-each loop </td>
	</tr>
	
	<tr>
		<td>for(String fruit:list1)</td>
	</tr>
	<tr>
		<td>System.out.println(fruit);</td>
	</tr>
	<tr>
		<td>System.out.println("Sorting numbers...");</td>
	</tr>
	<tr>
		<td>//Creating a list of numbers </td>
	</tr>
	<tr>
		<td>List<Integer> list2=new ArrayList<Integer>();</td>
	</tr>
	<tr>
		<td>list2.add(43);</td>
	</tr>
	<tr>
		<td>list2.add(32);</td>
	</tr>
	<tr>
		<td>list2.add(51);</td>
	</tr>
	<tr>
		<td>list2.add(11);</td>
	</tr>
	<tr>
		<td>list2.add(28);</td>
	</tr>
	<tr>
		<td>//Sorting the list  </td>	
	</tr>
	<tr>
		<td>Collections.sort(list2); </td>	
	</tr>
	<tr>
		<td>//Traversing list through the for-each loop </td>	
	</tr>
	<tr>
		<td>for(Integer number:list2) </td>	
	</tr>
	<tr>
		<td>System.out.println(number);</td>	
	</tr>
	
	
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>Output:</td>
	</tr>
	<tr>
		<td>Apple</td>
	</tr>
	<tr>
		<td>Nokia</td>
	</tr>
	<tr>
		<td>Samsung</td>
	</tr>
	<tr>
		<td>Sony</td>
	</tr>
	
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>}</td>
	</tr>
	<tr>
		<td>11</td>
	</tr>
	<tr>
		<td>28</td>
	</tr>
	<tr>
		<td>32</td>
	</tr>
	<tr>
		<td>43</td>
	</tr>
	<tr>
		<td>51</td>
	</tr>
	
</table>

	</p>
	</p>
	</div>

	<!-- Third Division -->
    <!-- <div class="col bg-success col-lg-2 sidenav"> -->
	<div class="col-sm-2 col-md-4 col-lg-2 border shadow bg-white">

	<p class="user-select-auto">
	<p class="font-weight-normal">

	</p>
	</p>
	</div>

	<!-- Division End -->

  </div>

 </div>
  <!-- Container End -->


<div class="card text-center border shadow bg-white>
  <div class="card-header">
   www.TechSearhWeb.com<br>
   Author:Bhagaban Patra.
  </div>

</div>

</body>
</html>
